<!DOCTYPE html>
<html lang="cs" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Negr</title>
    <link rel="stylesheet" href="styles.css">
    <style>:root { --primary: #7c3aed; }</style>
</head>
<body class="login-page">
    <!-- Animated background orbs -->
    <div class="bg-orbs">
        <div class="orb orb-1"></div>
        <div class="orb orb-2"></div>
        <div class="orb orb-3"></div>
    </div>
    
    <div class="login-container glass-panel">
        <div class="login-logo">
            <div class="logo-ring">
                <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                    <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                </svg>
            </div>
        </div>
        <h1>Negr</h1>
        <p class="subtitle">Zadej heslo pro pristup k vaultu</p>
        
        <form id="loginForm" class="login-form">
            <div class="input-group glass-input">
                <svg class="input-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>
                <input type="password" id="password" placeholder="Heslo..." autocomplete="off" autofocus>
            </div>
            <button type="submit" id="submitBtn" class="btn-primary glass-btn">
                <span class="btn-text">Odemknout</span>
                <span class="btn-loader hidden"></span>
                <svg class="btn-arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg>
            </button>
        </form>
        
        <div id="progress" class="progress-container hidden">
            <div class="progress-bar"><div class="progress-fill"></div></div>
            <span class="progress-text">Nacitani...</span>
        </div>
        
        <div id="error" class="error-message hidden"></div>
    </div>

    <script>
        const isMultiChunk = true;
        
        document.getElementById('loginForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const password = document.getElementById('password').value;
            const btn = document.getElementById('submitBtn');
            const error = document.getElementById('error');
            const progress = document.getElementById('progress');
            
            btn.disabled = true;
            btn.querySelector('.btn-text').classList.add('hidden');
            btn.querySelector('.btn-loader').classList.remove('hidden');
            error.classList.add('hidden');
            progress.classList.remove('hidden');
            
            try {
                let encryptedData = '';
                
                if (isMultiChunk) {
                    const manifest = await fetch('vault-manifest.json').then(r => r.json());
                    for (let i = 0; i < manifest.chunks; i++) {
                        const chunk = await fetch(`vault-data-${i}.enc`).then(r => r.text());
                        encryptedData += chunk;
                        updateProgress((i + 1) / manifest.chunks * 40);
                    }
                } else {
                    encryptedData = await fetch('vault-data.enc').then(r => r.text());
                    updateProgress(40);
                }
                
                const decrypted = await decryptData(encryptedData, password, (p) => {
                    updateProgress(40 + p * 60);
                });
                
                sessionStorage.setItem('vaultData', JSON.stringify(decrypted));
                sessionStorage.setItem('vaultUnlocked', 'true');
                window.location.href = 'app.html';
                
            } catch (err) {
                console.error(err);
                error.textContent = 'Špatné heslo nebo poškozená data';
                error.classList.remove('hidden');
                btn.disabled = false;
                btn.querySelector('.btn-text').classList.remove('hidden');
                btn.querySelector('.btn-loader').classList.add('hidden');
                progress.classList.add('hidden');
            }
        });
        
        function updateProgress(pct) {
            document.querySelector('.progress-fill').style.width = pct + '%';
            document.querySelector('.progress-text').textContent = Math.round(pct) + '%';
        }
        
        async function decryptData(encryptedBase64, password, onProgress) {
            const combined = Uint8Array.from(atob(encryptedBase64), c => c.charCodeAt(0));
            const metaLength = new DataView(combined.buffer).getUint32(0, false);
            const metadata = JSON.parse(new TextDecoder().decode(combined.slice(4, 4 + metaLength)));
            
            const salt = new Uint8Array(metadata.salt);
            const iv = new Uint8Array(metadata.iv);
            const key = await deriveKey(password, salt);
            
            let offset = 4 + metaLength;
            const chunks = [];
            const chunkSize = 64 * 1024 + 16;
            
            for (let i = 0; i < metadata.chunks; i++) {
                const chunkIv = new Uint8Array(iv);
                new DataView(chunkIv.buffer).setUint32(8, i, false);
                
                const encryptedChunk = combined.slice(offset, offset + chunkSize);
                offset += chunkSize;
                
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: chunkIv }, key, encryptedChunk
                );
                chunks.push(new Uint8Array(decrypted));
                if (onProgress) onProgress((i + 1) / metadata.chunks);
            }
            
            const totalLength = chunks.reduce((a, b) => a + b.length, 0);
            const result = new Uint8Array(totalLength);
            let pos = 0;
            chunks.forEach(c => { result.set(c, pos); pos += c.length; });
            
            return JSON.parse(new TextDecoder().decode(result));
        }
        
        async function deriveKey(password, salt) {
            const enc = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey('raw', enc.encode(password), { name: 'PBKDF2' }, false, ['deriveKey']);
            return crypto.subtle.deriveKey(
                { name: 'PBKDF2', salt, iterations: 100000, hash: 'SHA-256' },
                keyMaterial, { name: 'AES-GCM', length: 256 }, false, ['decrypt']
            );
        }
    </script>
</body>
</html>