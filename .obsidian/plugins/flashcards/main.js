/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FlashcardPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  cards: {}
};
var FlashcardPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("brain", "Open Flashcards", () => {
      this.openFlashcardModal();
    });
    this.addCommand({
      id: "open-flashcards",
      name: "Open Flashcards",
      callback: () => {
        this.openFlashcardModal();
      }
    });
    this.addCommand({
      id: "scan-flashcards",
      name: "Scan vault for flashcards",
      callback: async () => {
        await this.scanVault();
        new import_obsidian.Notice("Flashcards scanned!");
      }
    });
    this.addSettingTab(new FlashcardSettingTab(this.app, this));
  }
  async openFlashcardModal() {
    await this.scanVault();
    new FlashcardModal(this.app, this).open();
  }
  async scanVault() {
    const files = this.app.vault.getMarkdownFiles();
    const newCards = {};
    for (const file of files) {
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      let currentQuestion = "";
      let questionLine = -1;
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const qMatch = line.match(/^Q::\s*(.+)$/);
        if (qMatch) {
          currentQuestion = qMatch[1].trim();
          questionLine = i;
        }
        const aMatch = line.match(/^A::\s*(.+)$/);
        if (aMatch && currentQuestion) {
          const answer = aMatch[1].trim();
          const cardKey = this.hashCard(currentQuestion, answer);
          if (this.settings.cards[cardKey]) {
            newCards[cardKey] = this.settings.cards[cardKey];
          } else {
            newCards[cardKey] = {
              question: currentQuestion,
              answer,
              file: file.path,
              line: questionLine,
              interval: 0,
              repetition: 0,
              easeFactor: 2.5,
              dueDate: Date.now(),
              lastReview: 0
            };
          }
          currentQuestion = "";
          questionLine = -1;
        }
      }
    }
    this.settings.cards = newCards;
    await this.saveSettings();
  }
  hashCard(question, answer) {
    return `${question}|||${answer}`;
  }
  // SM-2 Algorithm (SuperMemo 2)
  updateCardSRS(card, quality) {
    if (quality < 3) {
      card.repetition = 0;
      card.interval = 0;
    } else {
      if (card.repetition === 0) {
        card.interval = 1;
      } else if (card.repetition === 1) {
        card.interval = 6;
      } else {
        card.interval = Math.round(card.interval * card.easeFactor);
      }
      card.repetition++;
    }
    card.easeFactor = card.easeFactor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
    if (card.easeFactor < 1.3) {
      card.easeFactor = 1.3;
    }
    card.dueDate = Date.now() + card.interval * 24 * 60 * 60 * 1e3;
    card.lastReview = Date.now();
    return card;
  }
  getDueCards() {
    const now = Date.now();
    return Object.values(this.settings.cards).filter((card) => card.dueDate <= now);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var FlashcardModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.currentCard = null;
    this.showingAnswer = false;
    this.plugin = plugin;
  }
  onOpen() {
    this.renderModal();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  renderModal() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("flashcard-modal-content");
    const dueCards = this.plugin.getDueCards();
    const totalCards = Object.keys(this.plugin.settings.cards).length;
    const statsDiv = contentEl.createDiv({ cls: "flashcard-stats" });
    statsDiv.createEl("h3", { text: "Flashcards" });
    statsDiv.createEl("p", { text: `Due: ${dueCards.length} / Total: ${totalCards}` });
    if (dueCards.length === 0) {
      contentEl.createEl("p", {
        text: "No cards due! Come back later or scan for new cards.",
        cls: "flashcard-empty"
      });
      const buttonContainer = contentEl.createDiv({ cls: "flashcard-empty-buttons" });
      const scanBtn = buttonContainer.createEl("button", {
        text: "Scan for cards",
        cls: "flashcard-action-btn"
      });
      scanBtn.addEventListener("click", async () => {
        await this.plugin.scanVault();
        this.renderModal();
        new import_obsidian.Notice("Vault scanned!");
      });
      const closeBtn2 = buttonContainer.createEl("button", {
        text: "Close",
        cls: "flashcard-action-btn flashcard-close-btn"
      });
      closeBtn2.addEventListener("click", () => {
        this.close();
      });
      return;
    }
    if (!this.currentCard) {
      this.currentCard = dueCards[Math.floor(Math.random() * dueCards.length)];
      this.showingAnswer = false;
    }
    const cardDiv = contentEl.createDiv({ cls: "flashcard-card" });
    const questionDiv = cardDiv.createDiv({ cls: "flashcard-question" });
    questionDiv.createEl("h2", { text: "Question:" });
    questionDiv.createEl("p", { text: this.currentCard.question });
    if (this.showingAnswer) {
      const answerDiv = cardDiv.createDiv({ cls: "flashcard-answer" });
      answerDiv.createEl("h2", { text: "Answer:" });
      answerDiv.createEl("p", { text: this.currentCard.answer });
      const buttonDiv = contentEl.createDiv({ cls: "flashcard-buttons" });
      const buttons = [
        { label: "Again", quality: 0, cls: "btn-again" },
        { label: "Hard", quality: 3, cls: "btn-hard" },
        { label: "Good", quality: 4, cls: "btn-good" },
        { label: "Easy", quality: 5, cls: "btn-easy" }
      ];
      buttons.forEach((btn) => {
        const button = buttonDiv.createEl("button", {
          text: btn.label,
          cls: btn.cls
        });
        button.addEventListener("click", () => this.rateCard(btn.quality));
      });
    } else {
      const showBtn = contentEl.createEl("button", {
        text: "Show Answer",
        cls: "btn-show-answer"
      });
      showBtn.addEventListener("click", () => {
        this.showingAnswer = true;
        this.renderModal();
      });
    }
    const footerDiv = contentEl.createDiv({ cls: "flashcard-footer" });
    const fileLink = footerDiv.createDiv({ cls: "flashcard-source" });
    fileLink.createEl("small", { text: `Source: ${this.currentCard.file}` });
    const closeBtn = footerDiv.createEl("button", {
      text: "Close",
      cls: "flashcard-close-btn-small"
    });
    closeBtn.addEventListener("click", () => {
      this.close();
    });
  }
  async rateCard(quality) {
    if (!this.currentCard)
      return;
    const cardKey = this.plugin.hashCard(this.currentCard.question, this.currentCard.answer);
    const updatedCard = this.plugin.updateCardSRS(this.currentCard, quality);
    this.plugin.settings.cards[cardKey] = updatedCard;
    await this.plugin.saveSettings();
    this.currentCard = null;
    this.showingAnswer = false;
    this.renderModal();
  }
};
var FlashcardSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Flashcard Settings" });
    new import_obsidian.Setting(containerEl).setName("Scan vault").setDesc("Scan your vault for flashcards (Q:: / A:: format)").addButton((button) => button.setButtonText("Scan now").onClick(async () => {
      await this.plugin.scanVault();
      new import_obsidian.Notice("Vault scanned for flashcards!");
    }));
    new import_obsidian.Setting(containerEl).setName("Reset all cards").setDesc("Reset all card progress (cannot be undone)").addButton((button) => button.setButtonText("Reset").setWarning().onClick(async () => {
      this.plugin.settings.cards = {};
      await this.plugin.saveSettings();
      await this.plugin.scanVault();
      new import_obsidian.Notice("All cards reset!");
    }));
    containerEl.createEl("h3", { text: "Statistics" });
    const totalCards = Object.keys(this.plugin.settings.cards).length;
    const dueCards = this.plugin.getDueCards().length;
    containerEl.createEl("p", { text: `Total cards: ${totalCards}` });
    containerEl.createEl("p", { text: `Cards due: ${dueCards}` });
  }
};
